##### [<-- back to README](/README.md)

## Java

### Общее

#### Основы синтаксиса

* Символы чувствительны к регистру.
* В названиях класса первая буква должна быть в верхнем регистре.
* В названиях методов первая буква должна быть в нижнем регистре.
* При использовании нескольких слов в названии класса или метода, первая буква каждого слова должна быть в верхнем регистре. Например: `MyJavaClass` для классов и `public void myMethodName()` для методов.
* Имя файла должно точно совпадать с именем класса, учитывая регистр.
* `public static void main(String args[])` – обработка программы начинается с метода `main()`, который является обязательной частью каждой программы.
* Файлы сохраняются с именем класса и расширением `.java` (MyJavaClass.java).

##### Идентификаторы

* Идентификаторы - это имена, которые используются для названия классов, методов и переменных.
* Идентификатор чувствителен к регистру.
* Каждый идентификатор должен начинаться с «A» до «Z» или «a» до «z», «$» или «_».
* После первого символа может иметь любую комбинацию символов.
* Ключевое слово не может быть использовано в качестве идентификатора.
* Пример правильного написания: age, $salary, _value, __1_value.
* Пример неправильного написания: 123abc, -salary.

##### Ключевые слова Java

* Ключевые слова нельзя употреблять в качестве константы или переменной, или любых других имен идентификаторов.

Всего зарегистрировано 50 ключевых слов:

* Примитивные типы: `byte`,`short`,`int`,`long`,`float`,`double`,`char`,`boolean`
* Управление потоком: `if`,`else`,`for`,`do`,`while`,`switch`,`case`,`default`,`break`,`continue`,`return`
* Обработка исключений: `try`,`catch`,`finally`,`throw`,`throws`,`assert`
* Модификаторы: `public`,`private`,`protected`,`final`,`static`,`native`,`abstract`,`synchronized`,`transient`,`volatile`,`strictfp`
* Связанные с классом: `class`,`interface`,`package`,`extends`,`implements`,`import`
* Связанный с объектом: `new`,`instanceof`,`super`,`this`
* Литералы: `true`,`false`,`null`
* Другие: `void`,`enum`
* Не используется: `goto`,`const`

##### Комментарии

* Поддерживаются однострочные и многострочные комментарии. Символы, размещённые внутри комментариев, недоступны для компилятора и игнорируются им.

```java
public class MyJavaProgram{

    /* В результате выполнения программы
     * на экран будет выведено "Hello world!"
     * Пример написания многострочного комментария
     */

    public static void main(String[] args){
       // Однострочный комментарий.
       /* Тоже однострочный комментарий. */
       System.out.println("Hello world!"); 
    }
}
```

#### JDK, JRE и JVM

* JDK (Java Development Kit) - набор программ для разработки. Включает в себя JRE, загрузчик кода java, компилятор javac, архиватор jar, генератор документации javadoc и другие утилиты.
* JRE (Java Runtime Environment) - окружение, необходимое для запуска Java-программ. Включает в себя JVM, стандартную библиотеку (пакеты lang, util, пакеты для работы с различными форматами, базами данных, пользовательским интерфейсом и другие пакеты).
* JVM (Java Virtual Machine) - виртуальная машина отвечает за выполнение байт-кода Java (.class).

#### Сборка, исполнение и архивация

Компиляция кода:

`javac HelloWorld.java`

* На выходе получаем файл HelloWorld.class

Запуск HelloWorld.class:

`java -cp . HelloWorld`  
 * Ключ `-cp` сокращение от `-classpath` указывает компилятору, где искать исходные файлы.

Компиляция кода с созданием каталогов:

`javac -d bin src/HelloWorld.java`  

На выходе получаем каталоги:  
* Исходный файл - `src/HelloWorld.java`  
* Скомпилированный файл - `bin/HelloWorld.class`

Запуск bin/HelloWorld.class из каталога:

`java -cp ./bin HelloWorld`

Архивация файлов (JAR - Java Archive):

`jar -cf jar-файл входной-файл(ы)`  
* Ключ `c` показывает, что необходимо создать (create) JAR-файл.
* Ключ `f` показывает, что необходимо направить вывод в файл, а не в стандартный поток вывода.
* `jar-файл` - название выходного JAR-файла с расширением `.jar`
* `входной-файл(ы)` - список файлов через пробел, которые необходимо поместить в JAR-файл.
* Команда `jar` автоматически создает файл `MANIFEST.MF` и помещает в каталог `META-INF`

Кроме JAR, также существуют другие архивы, связанные с Java:

* WAR (**W**eb **A**pplication A**r**chive) - содержит в себе приложение для веба.
* EAR (**E**nterprise **A**pplication A**r**chive) - содержит в себе энтерпрайз приложение (обычно из нескольких модулей).
* APK (**A**ndroid A**p**plication Pac**k**age) - содержит в себе приложение для Android.

### Типы данных

В Java доступны два типа данных:

* Примитивные типы данных (byte, short, char, int, long, float, double, boolean)
* Ссылочные типы данных (String, Integer, Character, ...)

#### Целочисленные типы

Тип|Описание|Размер (бит)|Диапазон|По умолчанию
:---:|---|:---:|---|:---:
byte | Наименьшие целые числа | 8 бит | от -128 до 127 | 0
short | Короткие целые числа | 16 бит | от -32768 до 32767 | 0
char | Символы | 16 бит | беззнаковое целое число, символ UTF-16 (буквы и цифры) | \u0000
int | Целые числа | 32 бит | от -2147483648 до 2147483647 | 0
long | Длинные дробные числа | 64 бит | от -9223372036854775808L до 9223372036854775807L | 0L

Литералы:

* Десятичное число (_Decimal_): `123`
* Восьмеричное число (_Octal_): `0123`
* Шестнадцатеричное число (_Hex_): `0x123`
* Двоичное число (_Binary_): `0b101` (с Java 7)
* С подчеркиванием: `123_456_789` (с Java 7)
* С суффиксом L для long: `123456789L`

#### Char (Unicode)

Литераллы:
* Символы в одинарных кавычках: `'a'`
* Шестнадцатеричный код символа: `'\u78bc'`

Управляющие последовательности (escape-последовательности):

Оператор|Описание
:---:|---
\t | Символ табуляции.
\b | Символ возврата в тексте на один шаг назад или удаление одного символа в строке (backspace).
\n | Символ перехода на новую строку.
\r | Символ возврата каретки.
\f | Прогон страницы.
\\' | Символ одинарной кавычки.
\\" | Символ двойной кавычки.
\\\ | Символ обратной косой черты (\\).
\\ddd | Восьмеричный символ (ddd)
\\uxxxx | Шестнадцатеричный символ UNICODE (xxxx)

##### Методы реализующие класс Character

`toLowerCase(char ch)` - преобразует все символы строки в нижний регистр.

`toUpperCase(char ch)` - преобразует все символы строки в верхний регистр.

`isLowerCase(char ch)` - определяет, находится ли указанное значение типа char в нижнем регистре.

`isUpperCase(char ch)` - определяет, находится ли указанное значение типа char в верхнем регистре.

`isDigit(char ch)` - определяет, является ли указанное значение типа char цифрой.

`isLetter(char ch)` - определяет, является ли указанное значение типа char буквой.

`isWhitespace(char ch)` - определяет, является ли указанное значение типа char пустым пространством, которое включает в себя пробел, табуляцию или новую строку.

`toString(char ch)` - возвращает строковый объект (String) и представляет указанное char-значение как одну символьную строку.


Некоторые символы представляются двумя char'ами - суррогатной парой.

Таблица ASCII:

![tableAscii](/img/tableAscii.jpg)

![ascii](/img/ascii.png)

#### Типы с плавающей точкой

Тип|Описание|Размер (бит)|Диапазон|По умолчанию
:---:|---|:---:|---|:---:
float | Длинные дробные числа | 32 бит | от 1.4e-45f до 3.4e+38f | 0,0f
double | Дробные числа двойной точности | 64 бит | от 4.9e-324 до 1.7e+308 | 0,0d

* Стандарт [IEEE754](https://ru.wikipedia.org/wiki/IEEE_754-2008)
* Побитовые операции не поддерживаются.

Литералы:

* Обычная запись: `-1.234`
* Экспоненциальная запись: `-123.4e-2` (−123.4 * 10−2)
* Шестнадцатеричная запись: `0xFFFFpFF` (FFFF * 2 FF)
* С суффиксом типа: `38f`, `3e19d`, `123.4e-2f`, `444.444d`

Особые случаи:

* Деление положительного числа на 0 дает +∞
* Деление отрицательного числа на 0 дает −∞
* Деление 0 на 0 дает NaN
* Переполнение дает +∞ или −∞, в зависимости от направления.
* NaN != NaN

Ключевое слово strictfp:

* Java использует FPU для вычислений с плавающей точкой, но регистры FPU могут быть шире 64 бит, в результате вычисления могут отличаться.
* Модификатор strictfp включает режим строгой совместимости, результаты будут идентичны на любом процессоре.

#### Логический тип

Тип|Описание|Размер (бит)|Диапазон
:---:|---|:---:|---
boolean	| Булевы выражения | 8 (в массивах) / 32 (не в массивах) | true (истина) или false (ложь)

#### Приведение типов

![cast](/img/cast.png)

Автоматические преобразования (с потерей точности):  
int --> float, long --> float и long --> double

```java
int a = 2147483647;
float b = a; // от типа int к типу float
System.out.println(b); // 2.14748365E9
```

Явные преобразования (с потерей точности):

```java
int a = 258;
byte b = (byte) a;
System.out.println(b); // 2
```

### Ссылочные

* Наследуются от `java.lang.Object`
* Ссылка может принимать значение `null`

#### Класс String

* Класс String для работы со строками (находится в пакете java.lang, его не нужно импортировать)
* Класс реализует интерфейсы Serializable и CharSequence.
* Класс String - final класс, который не может иметь потомков.
* Класс String - immutable класс, то есть его объекты не могут быть изменены после создания.
* Любые операции над объектом String, результатом которых должен быть объект класса String, приведут к созданию нового объекта.
* Благодаря своей неизменности, объекты класса String являются потокобезопасными и могут быть использованы в многопоточной среде.
* Каждый объект может быть преобразован в строку через метод toString, унаследованный всеми классами от класса Object.
* Строка - это не массив символов, хотя есть способы конвертации.
* Никаких нулевых символов в конце, длина хранится отдельно.

Строковые литералы:

```java
String zeros = "\u0000 \u0000";
String hello = "Hello";
String specialChars = "\r \n \t \" \\";
String unicodeEscapes = "\u0101 \u2134 \u03ff";
```

Создание из массива символов с помощью конструктора:

```java
char[] charArray = {’a’, ’b’, ’c’, ’d’};
String string = new String (charArray); // abcd
String string = new String (charArray, 0, 2); // ab
```

Конкатенация строк:

```java
String helloWorld = "Hello " + "World!"; // Hello World!
```

Классы StringBuilder и StringBuffer:

* Классы используются для работы со строками, без дублирования строк при изменении (находится в пакете java.lang)
* StringBuilder был введен в Java 5.
* Основное различие между StringBuilder и StringBuffer то, что методы StringBuilder не являются безопасными для потоков (несинхронизированные).
* Рекомендуется использовать StringBuilder, потому что он быстрее. Однако, если необходима безопасность потоков, наилучшим вариантом являются объекты StringBuffer.

```java
StringBuffer sBuffer = new StringBuffer("Тест");
sBuffer.append(" StringBuffer");    
System.out.println(sBuffer); // Тест StringBuffer
```

##### Методы реализующие классы StringBuilder и StringBuffer

`append((Object obj)` - обновляет значение объекта, который вызывает метод (принимает boolean, char, int, long, Strings и т.д.)

`reverse()` - изменяет значение объекта StringBuffer, который вызывает метод.

`delete(int start, int end)` - удаляет строку, начиная с начального индекса до конечного индекса.

`insert(int offset, Object obj)` - вставляет строку s в позицию, упомянутую по смещению.

`replace(int start, int end, String str)` - заменяет символы в подстроке данного StringBuffer символами в указанной строке.

```java
StringBuilder buf = new StringBuilder();
buf.append ("Hello ");
buf.append ("World!");
String result = buf.toString(); // Hello World!
```

Интернирование строк:

* Строка созданная как строковый литерал `String s = "Текст"` хранится в специальном месте кучи - пуле строк (string pool).
* В пуле строк хранятся исключительно уникальные значения строковых литералов.
* Процесс помещения строк в пул называется интернирование (interning).

```java
// Строка `s` и `s1` указывают на один объект в куче (пуле строк)
String s = "Текст";
String s1 = "Текст";
String s2 = new String("Текст"); // Указывает на новый объект в куче
```

Сравнение строк:

* Оператор `==` сравнивает ссылки, а не содержимое строки.
* Для сравнения содержимого строки существует метод `equals()`

```java
// Интернированные строки, указывают на один и тот же объект
"Текст" == "Текст" // true

// Переменные указывают на разные объекты
new String("Текст") == "Текст" // false
new String("Текст") == new String("Текст") // false
```

##### Методы реализующие класс String

`charAt(int index)` - возвращает символ по указанному индексу.

`compareTo(Object o)` - сравнивает данную строку с другим объектом.

`compareTo(String anotherString)` - сравнивает две строки лексически.

`compareToIgnoreCase(String str)` - сравнивает две строки лексически, игнорируя регистр букв.

`concat(String str)` - объединяет указанную строку с данной строкой, путем добавления ее в конце.

`contentEquals(StringBuffer sb)` - возвращает значение true только в том случае, если эта строка представляет собой ту же последовательность символов как указанно в буфере строки (StringBuffer).

`copyValueOf(char[] data)` - возвращает строку, которая представляет собой последовательность символов, в указанный массив.

`copyValueOf(char[] data, int offset, int count)` - возвращает строку, которая представляет собой последовательность символов, в указанный массив.

`endsWith(String suffix)` - проверяет, заканчивается ли эта строка указанным окончанием.

`equals(Object anObject)` - сравнивает данную строку с указанным объектом.

`equalsIgnoreCase(String anotherString)` - сравнивает данную строку с другой строкой, игнорируя регистр букв.

`getBytes()` - кодирует эту строку в последовательность байтов с помощью платформы charset, сохраняя результат в новый массив байтов.

`getBytes(String charsetName)` - кодирует эту строку в последовательность байтов с помощью платформы charset, сохраняя результат в новый массив байтов.

`getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)` - копирует символы из этой строки в массив символов назначения.

`hashCode()` - возвращает хэш-код для этой строки.

`indexOf(int ch)` - возвращает индекс первого вхождения указанного символа в данной строке.

`indexOf(int ch, int fromIndex)` - возвращает индекс первого вхождения указанного символа в данной строке, начиная поиск с указанного индекса.

`indexOf(String str)` - возвращает индекс первого вхождения указанной подстроки в данной строке.

`indexOf(String str, int fromIndex)` - возвращает индекс первого вхождения указанной подстроки в данной строке, начиная с указанного индекса.

`intern()` - возвращает каноническое представление для строкового объекта.

`lastIndexOf(int ch)` - возвращает индекс последнего вхождения указанного символа в этой строке.

`lastIndexOf(int ch, int fromIndex)` - возвращает индекс последнего вхождения указанного символа в этой строке, начиная обратный поиск с указанного индекса.

`lastIndexOf(String str)` - возвращает индекс последнего вхождения указанной подстроки в данной строке.

`lastIndexOf(String str, int fromIndex)` - возвращает индекс последнего вхождения указанной подстроки в этой строке, начиная обратный поиск с указанного индекса.

`length()` - возвращает длину строки.

`matches(String regex)` - сообщает, соответствует ли или нет эта строка заданному регулярному выражению.

`regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)` - проверяет равны ли две области строки.

`regionMatches(int toffset, String other, int ooffset, int len)` - проверяет равны ли две области строки.

`replace(char oldChar, char newChar)` - возвращает новую строку, в результате, заменив все вхождения oldChar в этой строке на newChar.

`replaceAll(String regex, String replacement)` - заменяет каждую подстроку строки, соответствующей заданному регулярному выражению с данной заменой.

`replaceFirst(String regex, String replacement)` - заменяет первые подстроки данной строки, которая соответствует заданному регулярному выражению с данной заменой.

`split(String regex)` - разделяет эту строку, окружая данным регулярным выражением.

`split(String regex, int limit)` - разделяет эту строку, окружая данным регулярным выражением.

`startsWith(String prefix)` - проверяет, начинается ли эта строка с заданного префикса.

`startsWith(String prefix, int toffset)` - проверяет, начинается ли эта строка с указанного префикса, начиная с указанного индекса.

`subSequence(int beginIndex, int endIndex)` - возвращает новую последовательность символов, которая является подпоследовательностью этой последовательности.

`substring(int beginIndex)` - возвращает новую строку, которая является подстрокой данной строки.

`substring(int beginIndex, int endIndex)` - возвращает новую строку, которая является подстрокой данной строки.

`toCharArray()` - преобразует эту строку в новый массив символов.

`toLowerCase()` - преобразует все символы в данной строке в нижний регистр, используя правила данного языкового стандарта.

`toLowerCase(Locale locale)` - преобразует все знаки в данной строке в нижний регистр, используя правила данного языкового стандарта.

`toString()` - этот объект (который уже является строкой!) возвращает себя.

`toUpperCase()` - преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта.

`toUpperCase(Locale locale)` - преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта.

`trim()` - возвращает копию строки с пропущенными начальными и конечными пробелами.

`valueOf(primitive data type x)` - возвращает строковое представление переданного типа данных аргумента.

#### Массивы

* Массив обозначается квадратными скобками.
* Класс Arrays для работы с массивами (находится в пакете java.util)

```java
int[] first;
int []first;
int first[];
int[] first, second;
```

Создание:

* Массив создается оператором `new`
* Все элементы массива инициализируются нулями.
* Размер массива фиксируется в момент создания.

```java
int[] numbers = new int[7];
String[] args = new String[5];
boolean[] bits = new boolean[0];
```

Инициализация:

* Можно перечислить значения всех элементов при создании массива.

```java
int[] numbers = new int[] {1, 2, 3, 4, 5};
boolean[] bits = new boolean[] {true, true, false};
char[] digits = {1, 2, 3, 4, 5}; // Работает только в объявлении переменной
int[] arr; arr = {1, 2, 3}; // Error: Array initializer is not allowed here
```

Индексация:

* Элементы индексируются с нуля.
* Длина массива доступна как `array.length`
* При выходе за границы массива бросается исключение `ArrayIndexOutOfBoundsException`

Многомерные массивы:

* Многомерный массив — это массив массивов.

```java
int[][] multi;
int [][]multi;
int[] multi[];
int[][] multi = new int[2][2];
int[] multi[] = new int[][] {{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}} // new int[3][4]
int[][] matrix = {{1, 2}, {3, 4}}; // matrix2[1][1] -> 4
int[] row = matrix[0]; // row[0] -> 1
```

* Разрешены ступенчатые массивы.

```java
int[][] triangle = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9},
        {10, 11, 12},
        {13, 14},
        {15}};
// triangle.length -> 5
// triangle[0].length -> 5
// triangle[4].length -> 1
```

Представление в памяти:

* Одномерный массив занимает непрерывный участок памяти.
* Двумерный массив занимает n + 1 участок в памяти, где n — первая размерность.

```java
int[][] a = new int[10][1000];
int[][] b = new int[1000][10];
```

Сравнение массивов:

* Сравнивает ссылки: `a == b`
* Сравнивает ссылки: `a.equals(b)`
* Сравнивает содержимое: `Arrays.equals(a, b)`
* Сравнивает содержимое многомерных массивов: `Arrays.deepEquals(a, b)`

Распечатка массива:

* Выводит название класса и хешкод "[I@2ce83912": `System.out.println(a)`
* Выводит содержимое: `System.out.println(Arrays.toString(a))`
* Выводит содержимое многомерных массивов: `System.out.println(Arrays.deepToString(a))`

##### Методы реализующие класс Arrays

`binarySearch(int[] a, int key)` - ищет в указанном массиве целых чисел указанное значение, используя алгоритм двоичного поиска..

`binarySearch(int[] a, int fromIndex, int toIndex, int key)` - ищет указанное значение в диапазоне указанного массива целых чисел, используя алгоритм двоичного поиска.

`copyOf(int[] original, int newLength)` - копирует указанный массив, усекая или дополняя нулями (при необходимости), чтобы копия имела указанную длину.

`copyOfRange(int[] original, int from, int to)` - копирует указанный диапазон указанного массива в новый массив.

`deepEquals(Object[] a1, Object[] a2)` - возвращает true, если два указанных массива "deeply equal" друг другу.

`deepHashCode(Object[] a)` - возвращает хэш-код на основе «deep contents» указанного массива.

`deepToString(Object[] a)` - возвращает строковое представление «deep contents» указанного массива.

`equals(int[] a, int[] a2)` - возвращает true, если два указанных массива целых чисел равны друг другу.

`fill(int[] a, int val)` - присваивает определенное значение int к каждому элементу указанного целочисленного массива.

`fill(int[] a, int fromIndex, int toIndex, int val)` - присваивает указанное значение int каждому элементу указанного диапазона указанного массива целых чисел.

`hashCode(int[] a)` - возвращает хэш-код на основе содержимого указанного массива.

`parallelPrefix(int[] array, IntBinaryOperator op)` - параллельно накапливает каждый элемент заданного массива на месте, используя предоставленную функцию.

`parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)` - выполняет parallelPrefix(int[], IntBinaryOperator) для данного поддиапазона массива.

`parallelSetAll(int[] array, IntUnaryOperator generator)` - установите все элементы указанного массива параллельно, используя предоставленную функцию генератора для вычисления каждого элемента.

`parallelSort(int[] a)` - сортирует указанный массив в возрастающем числовом порядке.

`parallelSort(int[] a, int fromIndex, int toIndex)` - сортирует указанный диапазон массива в возрастающем числовом порядке.

`setAll(int[] array, IntUnaryOperator generator)` - установите все элементы указанного массива, используя предоставленную функцию генератора для вычисления каждого элемента.

`sort(int[] a)` - сортирует указанный массив в возрастающем числовом порядке.

`sort(int[] a, int fromIndex, int toIndex)` - сортирует указанный диапазон массива в порядке возрастания.

`spliterator(int[] array)` - возвращает Spliterator.OfInt, охватывающий весь указанный массив.

`spliterator(int[] array, int startInclusive, int endExclusive)` - возвращает Spliterator.OfInt, охватывающий указанный диапазон указанного массива.

`stream(int[] array)` - возвращает последовательный IntStream с указанным массивом в качестве источника.

`stream(int[] array, int startInclusive, int endExclusive)` - возвращает последовательный IntStream с указанным диапазоном указанного массива в качестве источника.

`toString(int[] a)` - возвращает строковое представление содержимого указанного массива.

#### Классы-оболочки

Тип|Класс-обертка|Путь
:---:|:---:|:---:
byte | Byte | java.lang.Byte
short | Short | java.lang.Short
int | Integer | java.lang.Short
long | Long | java.lang.Long
char | Character | java.lang.Integer
float | Float | java.lang.Float
double | Double | java.lang.Double
boolean | Boolean | java.lang.Boolean

* Все оболочки числовых типов наследуют абстрактный класс `Number` (является частью пакета java.lang).
* Объекты классов-оберток являются неизменяемыми (Immutable).
* Переменной класса-обертки можно присваивать значение примитивного типа - автоупаковка (autoboxing).
* Переменной примитивного типа можно присваивать объект класса-обертки - автораспаковка (autounboxing).
* Автоупаковка и распаковка не работают для массивов.

Максимальное и минимальное значения:

* `MIN_VALUE` - максимальное числовое значение.
* `MAX_VALUE` - минимальное числовое значение.

Значения бесконечности:

`POSITIVE_INFINITY`

* Позитивное значение бесконечности типа double.
* Значение получается путем деления `-1,0` на `0,0`
* Строковое представление равно `-Infinity`
* Значение также является условным, и его шестнадцатеричное представление равно `FFF0000000000000`

`NEGATIVE_INFINITY`

* Отрицательное значение бесконечности типа double.
* Значение получается путем деления `1,0` на `0,0`
* Строковое представление равно `Infinity`
* Значение является условным, и его шестнадцатеричное представление равно `7FF0000000000000`

`NaN (Not-a-Number)`

* Числовое значение типа данных, которое означает «не число».
* Обычно указывает на результат недопустимых операций (разделить ноль на ноль)
* Используется для непредставимых значений (квадратный корень из -1)
* Эквивалентно значению, возвращаемому `Double.longBitsToDouble(0x7ff8000000000000L)`
* Эквивалентно значению, возвращаемому `Float.intBitsToFloat(0x7fc00000)`

##### Методы реализующие подклассы класса Number

`bitCount(int i)` - возвращает количество одиночных битов в двоичном представлении дополнения до двух указанного значения int.

`reverse(int i)` - возвращает значение, полученное путем изменения порядка битов в двоичном дополнении до двух указанного значения int.

`reverseBytes(int i)` - возвращает значение, полученное путем изменения порядка байтов в дополнительном представлении до двух указанного значения int.

`isNaN(double v)` - возвращает true, если указанное число является значением Not-a-Number (NaN), и false в противном случае.

`xxxValue()` - преобразует значение объекта Number, который вызывает метод, в примитивный тип данных, возвращаемый методом.

```java
Integer x = 5;
x.byteValue(); // 5
x.doubleValue(); // 5.0
x.longValue(); // 5L
```

`compareTo()` - сравнивает объект Number, вызвавший метод, с аргументом (нельзя сравнивать два разных типа аргумента)

```java
Integer x = 5;
x.compareTo(3); // 1
x.compareTo(5); // 0
x.compareTo(8); // -1
```

`equals()` - определяет, равен ли объект Number, вызывающий метод, объекту, который передается в качестве аргумента.

```java
Integer x = 5, y = 10, z = 5;
Short a = 5;

x.equals(y); // false
x.equals(z); // true
x.equals(a); // false
```

`valueOf()` – возвращает соответствующий числовой объект, содержащий значение переданного аргумента.

```java
Integer a = Integer.valueOf(9); // 9
Double b = Double.valueOf(5); // 5.0
Float c = Float.valueOf("80"); // 80.0
Integer d = Integer.valueOf("444", 16); // 1092
```

`toString()` - используется для получения объекта String, представляющего значение объекта Number. Если метод принимает примитивный тип данных в качестве аргумента, то возвращается объект String, представляющий значение примитивного типа данных. Если метод принимает два аргумента, будет возвращено строковое представление первого аргумента в системе счисления, заданной вторым аргументом.

```java
Integer x = 5;
x.toString(); // "5"
Integer.toString(12); // "12"
```

`parseXxx()` - используется для получения примитивного типа данных определенной строки. Является статическим методом и может иметь один или два аргумента.

```java
int x = Integer.parseInt("9"); // 9
double c = Double.parseDouble("5"); // 5.0
int b = Integer.parseInt("444", 16); // 1092
```

`toXxxxString()` - возвращает строковое представление целочисленного аргумента в виде целого числа без знака в Binary/Octal/Hex формате.

```java
int i = 5;
Integer.toBinaryString(i) // 10101010
Integer.toOctalString(i)// 252
Integer.toHexString(i) // aa
```

### Арифметические операции

Оператор|Описание
:---:|---
\+ | сложение
\- | вычитание
\* | умножение
/ | деление целочисленное
% | остаток / деление по модулю `9 % 4 = 1`
\+= | сложение с присваиванием
\-= | вычитание с присваиванием
\*= | умножение с присваиванием
/= | деление с присваиванием
%= | деление по модулю с присваиванием
\++ | инкремент
\-- | декремент

* Деление на ноль — выбрасывается исключение `ArithmeticException`
* Переполнение не является исключением, лишние старшие биты выкидываются.

#### Оператор инкремент / декремент

* Оператор предварительного приращения возвращает значение после приращения. Оператор постинкремента возвращает значение до инкремента.

```java
int i = 25;
int j = ++i; // i увеличивается до 26, присваивается j
System.out.println(i + " " + j); //26 26
        
i = 25;
j = i++; // i значение (25) присваивается j, затем увеличивается до 26
System.out.println(i + " " + j); // 26 25
```

```java
i = 25;
j = --i; // i уменьшается до 24, присваивается j
System.out.println(i + " " + j);//24 24

i = 25;
j = i--; // i значение (25) присваивается j, затем уменьшается до 24
System.out.println(i + " " + j); // 24 25
```

#### Класс Math

* Набор статических методов для осуществления математических вычислений.
* Располагается в пакете java.lang.

Методы:

`abs(double d)` - возвращает абсолютное значение аргумента.

`ceil(double d)` - возвращает целое число с нулевой дробной частью, ближайшее к числу аргумента справа.

`floor(double d)` - возвращает число с нулевой дробной частью, ближайшее к числу аргумента слева.

`rint(double d)` - возвращает целое число, которое ближайшее по значению аргумента

`round(double d)` - возвращает целое число, long или int, ближайшее к вещественному числу, double или float, аргумента.

`min(double arg1, double arg2)` - возвращает минимальное значение из двух аргументов.

`max(double arg1, double arg2)` - возвращает максимальное значение из двух аргументов.

`exp(double d)` - возвращает натуральный логарифм по основанию e и аргументу – показателю степени, где e – иррациональная константа, равная приблизительно 2,718281828.

`log(double d)` - возвращает натуральный логарифм аргумента.

`pow(double base, double exponent)` - возводит значение первого аргумента в степень второго аргумента, тем самым позволяет осуществить быстрое возведение в степень любых значений.

`sqrt(double d)` - возвращает квадратный корень из аргумента.

`sin(double d)` - возвращает синус указанного в радианах значения.

`cos(double d)` - возвращает косинус указанного в радианах значения.

`tan(double d)` - возвращает тангенс указанного в радианах значения.

`asin(double d)` - возвращает арксинус указанного в радианах значения.

`acos(double d)` - возвращает арккосинус указанного в радианах значения.

`atan(double d)` - возвращает арктангенс указанного в радианах значения.

`atan2(double y, double x)` - преобразует прямоугольные координаты (x, y) в полярные координаты (r, тета) и возвращает тета.

`toDegrees(double d)` - преобразует угол, измеряемый в радианах, в примерно эквивалентный угол, измеряемый в градусах.

`toRadians(double d)` - преобразует угол, измеряемый в градусах, в примерно эквивалентный угол, измеряемый в радианах.

`random()` - генерируют случайные числа в диапазоне от 0.0 до 1.0.


### Побитовые операции

Оператор | Описание
:---:|---
~ | Побитовый унарный оператор NOT
& | Побитовый AND
&= | Побитовый AND с присваиванием
&#124; | Побитовый OR
&#124;= | Побитовый OR с присваиванием
^ | Побитовый исключающее OR
^= | Побитовый исключающее OR с присваиванием
\>> | Сдвиг вправо
\>>= | Сдвиг вправо с присваиванием
\>>> | Сдвиг вправо с заполнением нулями
<< | Сдвиг влево
<<= | Сдвиг влево с присваиванием
\>>>= | Сдвиг вправо с заполнением нулями с присваиванием

`>>` - арифметический сдвиг  
`>>>` - логический сдвиг

A | B | A &#124; B | A & B | A ^ B | ~A
:---:|:---:|:---:|:---:|:---:|:---:
0 | 0 | 0 | 0 | 0 | 1
1 | 0 | 1 | 0 | 1 | 0
0 | 1 | 1 | 0 | 1 | 1
1 | 1 | 1 | 1 | 0 | 0

### Операторы сравнения (логические)

Оператор | Пример использования | Возвращает значение "true", если...
:---:|:---:|---
\> | a > b | а больше b
\>= | a >= b | а больше или равно b
< | a < b | а меньше b
<= | a <= b | а меньше или равно b
== | a == b | а равно b
!= | a != b | а не равно b
&& | a && b | а и b истинны, b оценивается условно (если а ложно, b не вычисляется)
&#124; &#124; | a &#124; &#124; b | а или b истинно, b оценивается условно (если а истинно, b не вычисляется)
! | !a | а ложно
& | a & b | а и b истинны, b оценивается в любом случае
&#124; | a &#124; b | а или b истинно, b оценивается в любом случае
^ | a ^ b | а и b различны

### Приоритет операторов

Оператор | Описание | Ассоциативность
:---:|---|:---:
++, — | постинкремент, постдекремент | справа налево
++, —, +, -, ~, ! | преинкремент, предекремент, унарный плюс, унарный минус, поразрядное дополнение, булево «не» | справа налево
*, /, % | умножение, деление, остаток от деления | слева направо
+, — | сложение, вычитание | слева направо
<<, >>, >>> | сдвиг влево, сдвиг вправо, беззнаковый сдвиг вправо | слева направо
<, >, \<=, >=, instanceof | меньше, больше, меньше или равно, больше или равно, сравнить тип | слева направо
==, != | равно, не равно | слева направо
& | битовое «и» | слева направо
^ | исключающее «или» | слева направо
&#124; | битовое «или» | слева направо
&& | логическое «и» | слева направо
&#124; &#124; | логическое «или» | слева направо
?: | тернарный оператор | слева направо
=, +=, -=,*=, /=, %=, &=, ^=, &#124; &#124;=, <<=, >>=, >>>= | операторы присваивания | справа налево

### Управляющие конструкции

#### Циклы и операторы цикла

##### Цикл while

`while (логическое выражение) { тело }`

```java
int num = 0;
while (num < 4) {
    System.out.print(num);
    num++;
} // 0123
```

##### Цикл for

`for (инициализация; условие; повторение) { тело }`

```java
int[] arr = {1, 2, 3, 4};
for (int i = 0; i < arr.length; i++) {
    System.out.print(arr[i]); 
} // 1234
```

##### Цикл do...while

`do { тело } while (логическое выражение);`

* Гарантированно выполнится хотя бы один раз.

```java
int num = 0;
do {
    System.out.print(num);
    num++;
} while (num < 4); // 0123
```

##### Усовершенствованный цикл for

`for (тип переменная : коллекция) { блок-операторов }`

* Компактная форма `for` для перебора элементов массивов, аналог foreach.
* В основном используется для переборов коллекция и массивов.

```java
int[] arr = {1, 2, 3, 4};
for (int i : arr) {
    System.out.print(i);
} // 1234
```

##### Оператор break

`break;`

* Используется для выхода из цикла.
* При использовании вложенных циклов оператор `break` осуществляет выход только из самого внутреннего цикла.
* Заканчивает последовательность операторов в ветвях оператора `switch`

```java
for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 100; j++) {
        System.out.print(i);
        break; // выходим из цикла j
    }
} // 0123
```

`break метка;`

* Применяется по аналогии оператора безусловного перехода `goto`
* В случае его срабатывания происходит переход к коду, который находится за блоком кода с заданной меткой.
* Его удобно использовать для выхода из вложенных циклов. Оператор break без метки позволяет перейти только на один уровень вверх, а с помощью break label можно сразу выйти из цикла любой вложенности.

```java
label:
for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 100; j++) {
        System.out.print(i);
        break label; // Переходим к метке label
    }
}
System.out.print(" End"); // 0 End
```

##### Оператор continue

`continue;`

* Заставляет цикл сразу же перейти к следующей итерации.
* В цикле `for` ключевое слово continue распоряжается процессом так, чтобы сразу же перейти к оператору обновления.
* В циклах `while` или `do...while`, контроль сразу же переходит в логическое выражение.

```java
for (int i = 0; i < 4; i++) {
    System.out.print(i);
    if (i < 3) {
        continue; // Переходит к следующей итерации i, пропуская код ниже
    }
    System.out.print(" Continue");
} // 0123 Continue
```

#### Операторы принятия решений

##### Оператор if

```java
if (выражение) {
    // Выполняется, если логическое выражение истинно
}
```

##### Вложенный оператор if

```java
if (выражение1) {
   // Выполняется, если логическое выражение1 истинно
   if (выражение2) {
      // Выполняется, если логическое выражение2 истинно
   }
}
```

##### Оператор if...else if...else

```java
if (выражение1) {
    // Выполняется, если логическое выражение1 истинно
} else if (выражение2) {
    // Выполняется, если логическое выражение2 истинно
    ...
} else if (выражениеN) {
    // Выполняется, если логическое выражениеN истинно
} else {
    //Выполняется, если все остальное ложно
}
```

##### Оператор switch...case

* Переменные, которые используются в операторе switch, могут быть только целые числа, конвертированные в целые числа (byte, short, char), строки и перечисления.
* Когда переменная switch равна оператору case, операторы следующие за case будут выполняться до тех пор, пока не будет достигнут оператор break.
* Не каждый case должен содержать break. Если отсутствует break, поток управления попадет на следующие case, до тех пор пока break не будет достигнут.
* Оператор switch может иметь дополнительный default case, который должен находиться в конце switch. Default case может быть использован для выполнения задачи, когда ни один из case является правильным. Break не требуется в default case.

```java
switch (выражение) {
        case значение1:
        // Выполнимся, если выражение равно значению1
        break;
        case значение2:
        // Выполнимся, если выражение равно значению2
        break;
        ...
        case значениеN:
        // Выполнимся, если выражение равно значениюN
        break;
        default: // можно не использовать
        // Выполнится, в любом случае
}
```

##### Условный / тернарный оператор

`<логическое выражение> ? <выражение1> : <выражение2>`

```java
int a = 0;
System.out.println(a == 1 ? "One" : "Not one"); // Not one
```

#### Оператор instanceof

`<ссылочная переменная объекта> instanceof <тип класса/интерфейса>`

* Оператор проверяет, относится ли объект к определенному типу.
* Используется только для переменных ссылки на объект.

```java
String str = "String";
boolean res = str instanceof String; // true
Vehicle a = new Car();
boolean res =  a instanceof Car; // true
```

### Методы

* Метод - блок кода, состоящий из ряда инструкций, являющийся в основном поведением. Содержит возвращаемый тип, название, аргументы и тело метода.

```java
public static int methodName(int a, int b) {
    // тело метода
    return возвращаемое_значение;
}
```

* `public static` (модификатор) - Определяет тип доступа к методу (его необязательно использовать)
* `int` (тип возвращаемого значения) - Метод может возвращать (int) или не возвращать (void) значение.
* `methodName` - имя метода.
* `int a, int b` (параметры метода) - Метод на входе может принимать аргументы в любого типа в любом порядке и количестве (метод может не иметь ни одного аргументов)
* `return` - (оператор возврата значения) - После оператора return указывается возвращаемое значение, которое является результатом метода.

Типы методов:

```java
// Без возвращаемого значения с аргументами
public void methodName(int a, int b) {
    System.out.println(a + b); // Выводит в консоль сумму a и b
}

// Без возвращаемого значения и без аргументов
public void methodName() {
    System.out.println("Текст") // Выводит в консоль текст
}

// С возвращаемым значением и аргументами
public int methodName(int a, int b) {
    return a + b; // возвращает сумму a и b
}

// С возвращаемым значением и без аргументов
public int methodName() {
    int a = 5, b = 7;
    return a + b; // возвращает сумму a и b
}
```

Вызов метода:

```java
public class Test {

    public static void methodName() {
        System.out.println("Текст");
    }

    public static void methodVoid(int a, int b) {
        System.out.println(a + b);
    }

    public static int methodReturn(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        methodName();
        methodVoid(5, 7);
        System.out.println(methodReturn(4, 5));
    }
}
```

Перегруженные методы:

* Если класс имеет два или более метода с одинаковыми именами, но разными параметрами.
* Перегруженные методы могут возвращать значение разного типа при условии, что параметры методов будут отличаться.

```java
public class Test {

    public static void sum(int a, int b) {
        System.out.println(a + b);
    }

    public static void sum(int a, int b, int c) {
        System.out.println(a + b + c);
    }

    public static int sum(int a, int b, int c, int d) {
        return a + b + c + d;
    }

    public static void main(String[] args) {
        sum(4, 5);
        sum(4, 5, 7);
        System.out.println(sum(1, 2, 3, 4));
    }
}
```

VarArgs (Список переменных аргументов):

* Специальный синтаксис для массива аргументов (Поддерживается с Java 5).
* Аргумент VarArgs должен стоять последним в списке аргументов, перед ним сколько угодно.

```java
int max(int... num); // max(1, 2, 3, 4);
int min(String s, int... num) // min("Numbers", 1, 2, 3, 4)
```

#### Использование аргументов командной строки

* Передача информации в программу через командную строку при запуске.
* Аргумент командной строки - это информация, которая следует непосредственно за именем программы в командной строке при ее выполнении.

```java
public class Test {
    public static void main(String[] args) {
        for(int i = 0; i < args.length; i++) {
            System.out.println("args[" + i + "]: " + args[i]);
        }
    }
}
```

Запуск программы через командную строку с параметрами:

`$java Test Текст 7 -5`

Результат:

```java
args[0]: Текст
args[1]: 7
args[2]: -5
```

#### Ключевое слово this

* Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена.

```java
class Test { 
    int num;
    Test(int num) {
        this.num = num; // this указывает на переменную экземпляра класса
    }
}
```

* Если нужно вызвать конструктор одного типа из другого (явный вызов конструктора)

```java
class Test { 
    int num
    Test() {
       this(7); // Вызывает конструктор с одним параметром
    }
    
    Test(int num) {
       this.num = num;
    }
}
```

### Объектно-ориентированное программирование

* Объектно-ориентированное программирование - парадигма программирования, в которой программа строится из взаимодействующих объектов.

#### Объекты и классы

* Класс - шаблонная конструкция позволяющая описать объект, его свойства (переменные или поля класса) и поведение (методы класса).
* Объект - экземпляр класса который имеет состояние и поведение. Например, у собаки есть состояние - цвет, имя, порода, а также поведение - виляет хвостом, лает, ест.

Создание объекта:

* Объявление - запись переменной с именем переменной и типом объекта.
* Создание экземпляра - создание объекта с помощью ключевого слова `new`
* Инициализация - за ключевым словом `new` следует вызов конструктора который инициализирует новый объект.

#### Типы переменных

Локальные переменные:

* Переменные, определенные внутри методов, конструкторов или блоков.
* Переменная объявляется и инициализируется внутри метода и будет уничтожена, когда метод завершится.
* Модификаторы доступа нельзя использовать для локальных переменных.
* Локальные переменные видны только внутри объявленного метода, конструктора или блока.
* Локальные переменные реализованы на уровне стека.
* Локальные переменные не имеют значение по умолчанию, значение должно быть присвоено до использования.

```java
public class Test {
    public static void main(String[] args) {
        int first = 0;
        fisrt = fisrt + 7; // 7
        int second;
        // second = second + 7 // Error: variable number might not have been initialized
    }
}   
```

Переменные экземпляра:

* Переменные определяются внутри класса, но за пределами метода, конструктора или любого блока.
* Когда для объекта в куче выделяется место, создается слот для каждого значения переменной экземпляра.
* Переменные экземпляра создаются при создании объекта с использованием ключевого слова `new` и уничтожаются при уничтожении объекта.
* Модификаторы доступа могут быть заданы для переменных экземпляра.
* Доступ к переменным экземпляра можно получить из любого метода, конструктора или блока.
* Переменные экземпляра имеют значения по умолчанию. Для чисел значение по умолчанию равно 0, для логических значений — false, а для ссылок на объекты — null.
* Значения могут быть присвоены во время объявления или в конструкторе.
* Переменная экземпляра может быть вызвана напрямую через имя переменной внутри класса. В статичных методах их следует вызывать с использованием полного имени `ObjectName.varName`

```java
public class Test {
    public int first; // Переменная экземпляра открыта для любого дочернего класса
    private int second; // Переменная экземпляра видна только в Test

    // Значение переменной first присваивается в конструкторе
    public Test(int num) {
        first = num;
    }
        
    // Значение переменной second присваивается в методе
    public void method (int num) {
        second = num;
    }

    public static void main(String[] args) {
        Test test = new Test(7);
        test.method(5);
    }
}   
```

Переменные класса (статические переменные):
* Объявляются внутри класса с ключевым словом static, вне любого метода, конструктора или блока.
* Статическая переменная, видна из всех экземпляров этого объекта, и ее значение не меняется от экземпляра к экземпляру, существует независимо от каких-либо экземпляров, поэтому оно принадлежит всему классу.
* Создается только одна копия каждой статической переменной в классе, независимо от того, сколько объектов создано из него.
* Статические переменные используются редко, кроме когда объявляются как константы. Константы - переменные, которые объявлены как public/private, final и static. Константы никогда не меняются от первоначального значения.
* Статические переменные создаются при запуске программы и уничтожаются при остановке программы.
* Статические переменные хранятся в "статической памяти" специальном пуле в памяти JVM, называемом Metaspace.
* Видимость похожа на переменные экземпляра. Однако большинство статических переменных объявляются общедоступными, поскольку они должны быть доступны для пользователей класса.
* Значения по умолчанию такое же, как и у переменных экземпляра. Для чисел по умолчанию равно 0, для данных типа boolean – false; и для ссылок на объект – null. Значения могут быть присвоены при объявлении или в конструкторе. Кроме того, они могут быть присвоены в специальных блоках статического инициализатора.
* Доступ к статическим переменным можно получить, вызвав имя класса `ClassName.varName`
* При объявлении переменных класса как `public static final` имена переменных (константы) пишутся в верхнем регистре.
* Если доступ к переменным осуществляется из внешнего класса, к константе следует обращаться как к `ClassName.CONSTANTA`

```java
public class Test {
    public static int first;
    static int second;
    public static final int TEST = 5; // Объявление статичной переменной (константа)

    public static void main(String[] args) {
        first = 7;
        Test.second = TEST; // 5
    }
}
```

#### Конструктор класса

* Конструктор - специальный метод, который вызывается при создании нового объекта.
* Конструкторы выполняют инициализацию объекта.
* Имя конструктора совпадает с именем класса, включая регистр.
* В отличие от метода, конструктор никогда ничего не возвращает.
* Конструкторы поддерживают перегрузку.
* Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров.

```java
public class Program {
    public static void main(String[] args) {
        Person bob = new Person(); // вызов первого конструктора без параметров
        bob.displayInfo(); // Name: Undefined - Age: 18

        Person tom = new Person("Tom"); // вызов второго конструктора с одним параметром
        tom.displayInfo(); // Name: Tom - Age: 19

        Person sam = new Person("Sam", 25); // вызов третьего конструктора с двумя параметрами
        sam.displayInfo(); // Name: Sam - Age: 25
    }
}

class Person {
    String name;
    int age;
    
    Person() {
        name = "Undefined";
        age = 18;
    }
    
    Person(String n) {
        name = n;
        age = 19;
    }
    
    Person(String n, int a) {
        name = n;
        age = a;
    }
    
    void displayInfo() {
        System.out.printf("Name: %s - Age: %d\n", name, age);
    }
}
```

#### Пакеты

* Пакеты позволяют объединить классы в группы, предотвращая конфликт с названиями имен, для контроля доступа, для облегчения поиска и использования классов, интерфейсов и аннотаций и т.д.
* Стандартные пакеты: java.lang, java.util, java.io и т.д

Создание пакета:

```java
package название_пакета;
```

Импорт пакетов и классов:

```java
import java.util.Scanner; // импорт класса Scanner
import java.util.*; // импорт всех классов из пакета java.util
```

Указание полного пути к файлу в пакете при создании объекта:

```java
java.util.Scanner in = new java.util.Scanner(System.in);
```

Статический импорт:

* При статическом импорте можно использовать методы без вызова его класса:

```java
import static java.lang.Math.*; // импорт статического класса Math
sqrt(20); // Вместо `Math.sqrt(20)`
```

#### Типы модификаторов

Модификаторы контроля доступа:

`public`

Публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.

`protected`

Такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах.

`default (package-private)`

Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

`private`

Закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.

Модификатор|Класс|Пакет|Наследники|Внешние классы
---|:---:|:---:|:---:|:---:
public | + | + | + |+
protected | + | + | + | -
default | + | + | - | -
private | + | - | - | -

* В исходном файле может быть только один публичный класс (public class).
* Исходный файл может иметь несколько "непубличных" классов.

Правила контроля доступа и наследования:

* Методы объявленные как public в суперклассе, также должны быть public во всех подклассах.
* Методы объявленные как protected в суперклассе, должны быть protected, либо public в подклассах (они не могут быть private).
* Методы объявленные как private не наследуются.

Модификаторы класса, метода, переменной и потока, используемые не для доступа:

##### Модификатор static

* Модификатор `static` применяется для создания методов и переменных класса.

Переменные static:

* Ключевое слово static используется для создания переменных, которые будут существовать независимо от каких-либо экземпляров, созданных для класса.
* Статические переменные являются общими для всего класса.
* Статические переменные также известны как переменные класса.
* Локальные переменные не могут быть объявлены статическими (static).

Методы static:

* Ключевое слово static используется для создания методов, которые будут существовать независимо от каких-либо экземпляров, созданных для класса.
* Переменные и методы класса могут быть доступны с использованием имени класса, за которым следует точка и имя переменной или метода.

##### Модификатор final

* Модификатор `final` используется для завершения реализации классов, методов и переменных.

Переменные final:

* Переменная final может быть инициализирована только один раз. Ссылочная переменная, объявленная как final, никогда не может быть назначен для обозначения другого объекта.
* При этом данные внутри объекта могут быть изменены. Таким образом, состояние объекта может быть изменено, но не ссылки.
* С переменными модификатор final часто используется со static, чтобы сделать константой переменную класса.

Методы final:

* Модификатор final предотвращает метод от изменений в подклассе. Не может быть переопределен.

Класс final:

* Класс объявленный как final не может быть подклассом.
* Ни один класс не может наследовать функции из класса final.

##### Модификатор abstract

* Модификатор `abstract` необходим для создания абстрактных классов и методов.

Класс abstract:

* Класс abstract не может создать экземпляр. Если класс объявлен как abstract, то единственная цель для него быть расширенным.
* Класс не может быть одновременно abstract и final, так как класс final не может быть расширенным.
* Если класс содержит абстрактные методы, то он должен быть объявлен как abstract.

Метод abstract:

* Метод abstract является методом, объявленным с любой реализацией. 
* Тело метода (реализация) обеспечивается подклассом. 
* Методы abstract никогда не могут быть final или strict.
* Любой класс, который расширяет абстрактный класс должен реализовать все абстрактные методы суперкласса, если подкласс не является абстрактным классом.
* Если класс содержит один или несколько абстрактных методов, то класс должен быть объявлен как abstract.
* Абстрактный класс не обязан содержать абстрактные методы.

##### Модификатор synchronized

* Модификаторы `synchronized` используются для потоков.

Модификатор synchronized:

* Ключевое слово synchronized используется для указания того, что метод может быть доступен только одним потоком одновременно.
* Модификатор synchronized может быть применен с любым из четырех модификаторов уровня доступа.

##### Модификатор transient

* Модификатор `transient` используется в процессе сериализации и десериализации объектов.


* Переменная экземпляра отмеченная как transient указывает виртуальной машине Java (JVM), чтобы пропустить определённую переменную при сериализации объекта, содержащего её.
* Этот модификатор включён в оператор, что создает переменную, предшествующего класса или типа данных переменной.

##### Модификатор volatile

* Модификатор `volatile` – используются в Java для потоков.


* Модификатор volatile используется, чтобы позволить знать JVM, что поток доступа к переменной всегда должен объединять свою собственную копию переменной с главной копией в памяти.
* Доступ к переменной volatile синхронизирует все кэшированные скопированные переменные в оперативной памяти.
* Volatile может быть применен только к переменным экземпляра, которые имеют тип объект или private.
* Ссылка на объект volatile может быть null.

### Исключения

![exceptions1](/img/exceptions1.png)

![exceptions2](/img/exceptions2.png)

### Коллекции

![collections](/img/collections.png)

### Приемы и хитрости

#### Замер скорости компиляции

```java
long nTime = System.nanoTime(); // Start
// Код
System.out.printf("Time -> %,1.3f ms\n", (System.nanoTime() - nTime)/1_000_000.0); // Stop
// System.out.println("Fast version: " + (double) fastVersion / 1000000000 + " s");
```